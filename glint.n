import request
import json
import FileIO

let utils = imp "./utils.n"

let main = [] -> cmd[()] {
  let config = utils.parseConfig(json.parse(FileIO.read("config/config.json")! |> default("")))

  let possibleToken = FileIO.read("config/.token")!
  let authHeader = mapFrom([
    (if let <yes token> = possibleToken { ("Authorization", "token " + token) } else { ("", "") })
  ])

  let reviewEntries = mapFrom([("unknown", { timesRequested: 0; timesResponded: 0; averageResponseTime: 0; })])

  let pullResponse = request.get("https://api.github.com/repos/" + config.repoAuthor + "/" + config.repoName + "/pulls?state=all&per_page=100", authHeader)!

  if pullResponse.code /= 200 {
    print("Incorrect Authorization or Repo Does not Exist")
    return ()
  }

  let teamMembersRaw = []
  if config.checkTeams {
    print("Aggregating team data")
    let teamResponseData = request.get("https://api.github.com/orgs/getoutreach/teams?per_page=100", authHeader)!
    if teamResponseData.code == 200 {
      if let <array teams> = teamResponseData.return {
        let percentMultiplier = 100.0/toFloat(len(teams))
        let index = 0.0
        for (possibleTeam in teams) {
          if let <object team> = possibleTeam {
            if let <yes <string name>> = team["slug"] {
              let members = []
              let teamMembersData = request.get("https://api.github.com/orgs/getoutreach/teams/" + name + "/members?per_page=100", authHeader)!
              if (teamMembersData.code == 200) {
                if let <array teamMembers> = teamMembersData.return {
                  for (possibleMember in teamMembers) {
                    if let <object member> = possibleMember {
                      if let <yes <string login>> = member["login"] {
                        var members = members |> append(login)
                      }
                    }
                  }
                }
              }
              var teamMembersRaw = teamMembersRaw |> append((name, members))
            }
          }
          printWithEnd("\r", "[" + utils.GREEN + utils.multString(round(index), "#") + utils.multString(100 - round(index), " ") + utils.RESET + "] " + utils.YELLOW + intInBase10(round(index)) + "%" + utils.RESET)
          var index = index + percentMultiplier
        }
      }
    print("[" + utils.GREEN + utils.multString(100, "#") + utils.RESET + "] " + utils.YELLOW + "100%" + utils.RESET)
    }
  }

  let teamMembers = mapFrom(teamMembersRaw)

  print("Aggregating PR data")

  let index = 0

  if let <array pulls> = pullResponse.return {
    for (pull in pulls) {
      if let <object pullData> = pull {
        if let <yes <boolean draft>> = pullData["draft"] {
          if not draft {
            if config.checkTeams {
              if let <yes <array requestedTeams>> = pullData["requested_teams"] {
                for (possibleTeam in requestedTeams) {
                  if let <object team> = possibleTeam {
                    let slug = "unknown"
                    if let <yes <string sl>> = team["slug"] {
                      var slug = sl
                    }
                    let ent = entries(reviewEntries)
                    let reviewerData = reviewEntries[slug] |> default({ timesRequested: 0; timesResponded: 0; averageResponseTime: 0; })
                    var reviewEntries = mapFrom([
                      ..ent,
                      (slug, {
                        ..reviewerData
                        timesRequested: reviewerData.timesRequested + 1
                      }),
                    ])
                  }
                }
              }
            } else {
              if let <yes <array requestedReviewers>> = pullData["requested_reviewers"] {
                for (possibleReviewer in requestedReviewers) {
                  if let <object reviewer> = possibleReviewer {
                    let login = "unknown"
                    if let <yes <string log>> = reviewer["login"] {
                      var login = log
                    }
                    let ent = entries(reviewEntries)
                    let reviewerData = reviewEntries[login] |> default({ timesRequested: 0; timesResponded: 0; averageResponseTime: 0; })
                    var reviewEntries = mapFrom([
                      ..ent,
                      (login, {
                        ..reviewerData
                        timesRequested: reviewerData.timesRequested + 1
                      }),
                    ])
                  } 
                }
              }
            }
            if let <yes <number pullNumber>> = pullData["number"] {
              let reviewData = request.get("https://api.github.com/repos/" + config.repoAuthor + "/" + config.repoName + "/pulls/" + intInBase10(round(pullNumber)) + "/reviews", authHeader)!
              if reviewData.code == 200 {
                if let <array reviews> = reviewData.return {
                  for (possibleReview in reviews) {
                    if let <object review> = possibleReview {
                      if let <yes <object user>> = review["user"] {
                        let login = "unknown"
                        if let <yes <string log>> = user["login"] {
                          var login = log
                        }
                        if (config.checkTeams) {
                          let slugs = utils.getUserTeams(login, teamMembersRaw)
                          for (slug in slugs) { 
                            let ent = entries(reviewEntries)
                            let reviewerData = reviewEntries[slug] |> default({ timesRequested: 0; timesResponded: 0; averageResponseTime: 0; })
                            var reviewEntries = mapFrom([
                              ..ent,
                              (slug, {
                                ..reviewerData
                                timesResponded: reviewerData.timesResponded + 1
                                // It is assumed that the times they respond it is because they were requested
                                timesRequested: reviewerData.timesRequested + 1
                              }),
                            ])
                          }
                        } else {
                          let ent = entries(reviewEntries)
                          let reviewerData = reviewEntries[login] |> default({ timesRequested: 0; timesResponded: 0; averageResponseTime: 0; })
                          var reviewEntries = mapFrom([
                            ..ent,
                            (login, {
                              ..reviewerData
                              timesResponded: reviewerData.timesResponded + 1
                              // It is assumed that the times they respond it is because they were requested
                              timesRequested: reviewerData.timesRequested + 1
                            }),
                          ])
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      printWithEnd("\r", "[" + utils.GREEN + utils.multString(index, "#") + utils.multString(100 - index, " ") + utils.RESET + "] " + utils.YELLOW + intInBase10(index) + "%" + utils.RESET)
      var index = index + 1
    }
    print("[" + utils.GREEN + utils.multString(100, "#") + utils.RESET + "] " + utils.YELLOW + "100%" + utils.RESET)
  }

  let jsonData = json.object(mapFrom([
    ("info", json.object(mapFrom([
      ("isTeams", json.boolean(config.checkTeams)),
      ("organization", json.string(config.repoAuthor)),
      ("repoName", json.string(config.repoName)),
    ]))),
    ("data", utils.reviewDataToJson(reviewEntries)),
  ]))
  let binaryJsonData = utils.convertTextToBytes(json.stringify(jsonData))
  let binaryIconData = FileIO.readBytes("site/favicon.ico")! |> default([])

  if config.export {
    let _ = FileIO.write("export.json", json.stringify(jsonData))!

    print("Exporting json...")
  }

  let _ = request.createServer(
    8080,
    [path:str _:str _:json.value] -> cmd[{ responseCode:int; data:list[int]; headers:map[str, str]; mimetype:str }] {
      if path == "data" {
        return {
          responseCode: 200
          data: binaryJsonData
          headers: mapFrom([
            ("access-control-allow-origin", "*"),
            ("content-type", "application/json"),
          ])
          mimetype: "application/json"
        }
      }

      if path == "favicon.ico" {
        return {
          responseCode: 200
          data: binaryIconData
          headers: mapFrom([
            ("access-control-allow-origin", "*"),
            ("content-type", "image/vnd.microsoft.icon"),
          ])
          mimetype: "image/vnd.microsoft.icon"
        }
      }

      // Development purposes: will move back later
      let mainPage = FileIO.readBytes("site/template.html")! |> default(utils.convertTextToBytes("uh oh! The template.html file was removed!"))

      return {
        responseCode: 200
        data: mainPage
        headers: mapFrom([
          ("access-control-allow-origin", "*"),
          ("content-type", "text/html"),
        ])
        mimetype: "text/html"
      }
    }
  )!
}

let pub out = main()